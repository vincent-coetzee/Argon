//
//  Module.swift
//  Argon
//
//  Created by Vincent Coetzee on 27/01/2023.
//

import Foundation

//
//
// Argon allows Modules to opened and closed repeatedly, the parser will
// amalgamate all the declarations spread out over these multiple openings
// and closings of a particular Module into a single instance of that Module
// because there can only be a single instance of a Module with the same
// name in a project. I have yet to ascertain if and how Modules will be aggreagted
// across multiple projects - which is theoretically allowed. I suspect the name
// mangling of Module, Method, Function, Variable and Constant symbols will resolve the
// problem. If there is more than one instance of a Module in more than one
// object files generated by a project then as long as there is not more than
// one instance of a symbol with the same mangled name across the multiple
// object files then everything should work. If there is more than one
// the static linker should raise an error regarding the duplicate symbol which
// is correct. I need to find a way to encode the Module itself so that it does
// not trigger a static linker error.
//
//

public class ModuleType: StructuredType
    {
    public var hasMainMethod: Bool
        {
        self.mainMethod.isNotNil
        }
        
    public var mainMethod: MultimethodType?
        {
        if let method = self.lookupMethod(atName: "main")
            {
            return(method)
            }
        return(nil)
        }
        
    public override var module: ModuleType
        {
        self
        }
        
    public override var isModuleType: Bool
        {
        true
        }
        
    public override var symbolType: ArgonType
        {
        self
        }
        
    public override var parentModules: Modules
        {
        self.container?.parentModules.appending(self) ?? Modules()
        }
        
    public class func parseModuleDependency(using parser: ArgonParser) -> ModuleNode?
        {
        parser.nextToken()
        guard parser.token.isIdentifier else
            {
            return(nil)
            }
        parser.nextToken()
        fatalError()
        }
        
    public class override func parse(using parser: ArgonParser)
        {
        let location = parser.token.location
        parser.nextToken()
        let module = self.parseForModule(using: parser,location: location)
        parser.pushCurrentScope(module)
        defer
            {
            parser.popCurrentScope()
            }
        self.parseModuleContents(using: parser,into: module)
        }
        
    private class func parseForModule(using parser: ArgonParser,location: Location) -> ModuleType
        {
        if let lastToken = parser.expect(tokenType: .identifier,error: .moduleNameExpected)
            {
            let moduleName = lastToken.identifier.lastPart
            if let node = parser.lookupSymbol(atName: moduleName)
                {
                if node.isModuleType
                    {
                    return(node as! ModuleType)
                    }
                else
                    {
                    parser.lodgeError(code: .identifierAlreadyDefined,location: location)
                    return(ModuleType(name: Argon.nextIndex(named: "MODULE_")))
                    }
                }
            else
                {
                let module = ModuleType(name: moduleName)
                parser.addSymbol(module)
                if lastToken.identifier.isCompoundIdentifier
                    {
                    parser.lodgeError(code: .moduleNameExpected,location: location)
                    }
                return(module)
                }
            }
        else
            {
            return(ModuleType(name: Argon.nextIndex(named: "MODULE_")))
            }
        }
        
    private class func parseModuleContents(using parser: ArgonParser,into module: ModuleType)
        {
        let location = parser.token.location
        module.location = location
        if parser.expect(tokenType: .leftBrace, error: .leftBraceExpected).isNotNil
            {
            while !parser.token.isRightBrace
                {
                switch(parser.token.tokenType)
                    {
                    case(.LET):
                        LetStatement.parse(using: parser)
                    case(.CONSTANT):
                        Constant.parse(using: parser)
                    case(.CLASS):
                        ClassType.parse(using: parser)
                    case(.METHOD):
                        MethodType.parse(using: parser)
                    case(.TYPE):
                        AliasedType.parse(using: parser)
                    case(.MODULE):
                        ModuleType.parse(using: parser)
                    case(.FUNCTION):
                        FunctionType.parse(using: parser)
                    case(.ENUMERATION):
                        EnumerationType.parse(using: parser)
                    default:
                        parser.lodgeError(code: .moduleEntryExpected,location: location)
                    }
                }
            }
        }
        
    internal var symbols = Symbols()
    
    public override func addSymbol(_ symbol: Symbol)
        {
        if symbol.isMethod
            {
            if let multimethod = self.lookupSymbol(atName: symbol.name) as? MultimethodType
                {
                multimethod.addMethod(symbol as! MethodType)
                return
                }
            let multimethod = MultimethodType(name: symbol.name)
            multimethod.addMethod(symbol as! MethodType)
            multimethod.setContainer(self)
            self.symbols.append(multimethod)
            return
            }
        self.symbols.append(symbol)
        symbol.setContainer(self)
        }
        
    public override func lookupSymbol(atName: String) -> Symbol?
        {
        for node in self.symbols
            {
            if node.name == atName
                {
                return(node)
                }
            }
        return(self.container?.lookupSymbol(atName: atName))
        }
        
    public override func lookupMethod(atName someName: String) -> MultimethodType?
        {
        let method = MultimethodType(name: someName)
        for symbol in self.symbols
            {
            if symbol.name == someName && symbol.isMultimethod
                {
                method.append(contentsOf: symbol as? MultimethodType)
                }
            }
        if let parentMethod = self.container?.lookupMethod(atName: someName) as? MultimethodType
            {
            let signatures = Set(method.signatures)
            for aMethod in parentMethod.methods
                {
                if !signatures.contains(aMethod.signature)
                    {
                    method.addMethod(aMethod)
                    }
                }
            }
        return(method)
        }
    //
    //
    // When visiting a regular module we visit
    // both the node of the entry and the methods
    // of the entry. In the case of an ArgonModule
    // accept does nothing because system classes and
    // methods do not need to be visited. In the case
    // of a RootModule only the nodes are visited
    // because there should not be any methods in the
    // RootModule.
    //
    public override func accept(visitor: Visitor)
        {
        visitor.enter(module: self)
        for symbol in self.symbols
            {
            symbol.accept(visitor: visitor)
            }
        visitor.exit(module: self)
        }
        
    public func validateMethodUniqueness(semanticChecker: ArgonSemanticChecker)
        {
        let methods = self.symbols.compactMap{$0 as? MethodType}
        for method in methods
            {
            for innerMethod in methods.removing(method)
                {
                if innerMethod.signature == method.signature
                    {
                    semanticChecker.lodgeError(code: .methodWithDuplicateSignature, location: method.location!,message: "Duplicate method '\(method.name)' with signature \(method.signature)")
                    }
                }
            }
        for module in self.symbols.compactMap({$0 as? ModuleType})
            {
            module.validateMethodUniqueness(semanticChecker: semanticChecker)
            }
        }
    }

public typealias Modules = Array<ModuleType>
