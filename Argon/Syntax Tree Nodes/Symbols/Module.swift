//
//  Module.swift
//  Argon
//
//  Created by Vincent Coetzee on 27/01/2023.
//

import Foundation

//
//
// Argon allows Modules to opened and closed repeatedly, the parser will
// amalgamate all the declarations spread out over these multiple openings
// and closings of a particular Module into a single instance of that Module
// because there can only be a single instance of a Module with the same
// name in a project. I have yet to ascertain if and how Modules will be aggreagted
// across multiple projects - which is theoretically allowed. I suspect the name
// mangling of Module, Method, Function, Variable and Constant symbols will resolve the
// problem. If there is more than one instance of a Module in more than one
// object files generated by a project then as long as there is not more than
// one instance of a symbol with the same mangled name across the multiple
// object files then everything should work. If there is more than one
// the static linker should raise an error regarding the duplicate symbol which
// is correct. I need to find a way to encode the Module itself so that it does
// not trigger a static linker error.
//
//

public class Module: CompositeSyntaxTreeNode
    {
    public var hasMainMethod: Bool
        {
        self.mainMethod.isNotNil
        }
        
    public var mainMethod: MethodType?
        {
        for symbol in self.lookupMethods(atName: "main")
            {
            if symbol.isMethod
                {
                return(symbol)
                }
            }
        return(nil)
        }
        
    public override var module: Module
        {
        self
        }
        
    public override var isModuleType: Bool
        {
        true
        }
        
    public override var nodeType: NodeType
        {
        return(.module)
        }
        
    public override var parentModules: Modules
        {
        self.container?.parentModules.appending(self) ?? Modules()
        }
        
    public class func parseModuleDependency(using parser: ArgonParser) -> ModuleNode?
        {
        parser.nextToken()
        guard parser.token.isIdentifier else
            {
            return(nil)
            }
//        let name = parser.token.identifier.description
        parser.nextToken()
//        while !parser.token.isImport && !parser.token.isEnd
        fatalError()
        }
        
    public class override func parse(using parser: ArgonParser)
        {
        let location = parser.token.location
        parser.nextToken()
        let module = self.parseForModule(using: parser,location: location)
        parser.pushCurrentScope(module)
        defer
            {
            parser.popCurrentScope()
            }
        self.parseModuleContents(using: parser,into: module)
        }
        
    private class func parseForModule(using parser: ArgonParser,location: Location) -> Module
        {
        if let lastToken = parser.expect(tokenType: .identifier,error: .moduleNameExpected)
            {
            let moduleName = lastToken.identifier.lastPart
            if let node = parser.lookupSymbol(atName: moduleName)
                {
                if node.isModuleType
                    {
                    return(node as! Module)
                    }
                else
                    {
                    parser.lodgeError(code: .identifierAlreadyDefined,location: location)
                    return(Module(name: Argon.nextIndex(named: "MODULE_")))
                    }
                }
            else
                {
                let module = Module(name: moduleName)
                parser.addSymbol(module)
                if lastToken.identifier.isCompoundIdentifier
                    {
                    parser.lodgeError(code: .moduleNameExpected,location: location)
                    }
                return(module)
                }
            }
        else
            {
            return(Module(name: Argon.nextIndex(named: "MODULE_")))
            }
        }
        
    private class func parseModuleContents(using parser: ArgonParser,into module: Module)
        {
        let location = parser.token.location
        module.location = location
        if parser.expect(tokenType: .leftBrace, error: .leftBraceExpected).isNotNil
            {
            while !parser.token.isRightBrace
                {
                switch(parser.token.tokenType)
                    {
                    case(.LET):
                        LetStatement.parse(using: parser)
                    case(.CONSTANT):
                        Constant.parse(using: parser)
                    case(.CLASS):
                        ClassType.parse(using: parser)
                    case(.METHOD):
                        MethodType.parse(using: parser)
                    case(.TYPE):
                        AliasedType.parse(using: parser)
                    case(.MODULE):
                        Module.parse(using: parser)
                    case(.FUNCTION):
                        FunctionType.parse(using: parser)
                    case(.ENUMERATION):
                        EnumerationType.parse(using: parser)
                    default:
                        parser.lodgeError(code: .moduleEntryExpected,location: location)
                    }
                }
            }
        }
    //
    //
    // When visiting a regular module we visit
    // both the node of the entry and the methods
    // of the entry. In the case of an ArgonModule
    // accept does nothing because system classes and
    // methods do not need to be visited. In the case
    // of a RootModule only the nodes are visited
    // because there should not be any methods in the
    // RootModule.
    //
    public override func accept(visitor: Visitor)
        {
        visitor.enter(module: self)
        for symbol in self.symbols
            {
            symbol.accept(visitor: visitor)
            }
        visitor.exit(module: self)
        }
        
    public func validateMethodUniqueness(semanticChecker: ArgonSemanticChecker)
        {
        let methods = self.symbols.compactMap{$0 as? MethodType}
        for method in methods
            {
            for innerMethod in methods.removing(method)
                {
                if innerMethod.signature == method.signature
                    {
                    semanticChecker.lodgeError(code: .methodWithDuplicateSignature, location: method.location!,message: "Duplicate method '\(method.name)' with signature \(method.signature)")
                    }
                }
            }
        for module in self.symbols.compactMap{$0 as? Module}
            {
            module.validateMethodUniqueness(semanticChecker: semanticChecker)
            }
        }
    }

public typealias Modules = Array<Module>
